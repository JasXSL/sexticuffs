// Create classes

// Base asset
class Asset{
    
    constructor(){

        this.UUID = '';

    }

    load(data){
        for(var i in data){
            if(this.hasOwnProperty(i)){
                this[i] = data[i];
            }
        }
        if(this.UUID === ''){this.generateUUID();}
        
        this.onLoaded();
    }

    generateUUID(){
        this.UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    }

    clone(){
        var asset = new this.constructor();

        for(var i in this){
            var d = this[i];

            if(asset[i] !== undefined && asset[i] !== null && asset[i].constructor === Array){
                d = d.slice();
            }
            asset[i] = d;
        }
        asset.generateUUID();
		asset.onClone();
        return asset;
    }
    

    // Overwrite these
    onLoaded(){}
    onClone(){}
	onAdd(){}


    // Static methods

    // Searches the database by id if id field exists
    static get(id){

        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be identified because it doesn't have a library entry");
            return;
        }

        if(!new this().hasOwnProperty('id')){
            console.error('Error, object "'+this.className()+'" doesn\'t have an id field');
            return false;
        }

        var scan = DB[this.className()];
        for(var i=0; i<scan.length; ++i){
            var asset = scan[i];
            if(asset.id === id){
                return asset;
            }
        }

		console.error("Search for ", id, "in", this.className(), "yielded no results");
        return false;
    }

    // Searches the library for one or more objects
    static search(obj){

        
        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be searched because it doesn't have a library entry");
            return [];
        }

        var scan = DB[this.className()];
        var out = [];
        for(var i=0; i<scan.length; ++i){
            var asset = scan[i];
            if(this.compare(obj, asset)){
                out.push(asset);
            }
        }
        return out;
    }
    
    // Compares a search query object to an asset
    static compare(obj, asset){
        for(var i in obj){
            if(!asset.hasOwnProperty(i) || asset[i] !== obj[i]){
                return false;
            }
        }
        return true;
    }

    // Inserts into the library
    static insert(data){

        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be inserted because it doesn't have a library entry");
            return;
        }

        var add = new this(data);
		var db = DB[this.className()];
        db.push(add);
		add.onAdd();
    }

    static className(){
        return new this().constructor.name;
    }


	static convertArray(input){
		var i, out = [];
		for(i=0; i<input.length; ++i){
			out.push(new this(input[i]));
		}
		return out;
    }

}

















// Character
class Character extends Asset{

    constructor(data){
        super();

        this.id = '';       		// used only for NPCs, use UUID for PC
		this.socket_id = '';		// Identifier for websocket
        this.name = '';
        this.description = '';
		this.image = '';

        this.is_pc = false;
        this.abilities = [];
		this.abilities_unlocked = [];		// IDs
        this.tags = ["c_penis"];
		this.pronouns = [];				// Needs to be exactly 3 entries or they will be autogenerated: he/him/his | she/her/her | etc
		this.race = Race.get('fox');
		this.body_tags = [];			// For RP texts, things like fuzzy, shiny, spotted etc
		this.affinity = Ability.AffinityOffensive;
		


		// PC only essentially
		this.unspent_points = 0;
		this.experience = 0;
		this.cash = 0;

		// Meta generated on save
		this.modified = Date.now();

        this.team = Character.TEAM_NPC;

        this.armorSet = new Armor();
		this.armor_unlocked = ["goldenThong", "goldenBikini"]; // IDs


        // Max stats
        this.max_armor = 20;	// Should prevent certain enemy abilities, but can't be healed reliably
        this.max_hp = 20;		// Can be healed
        this.max_mana = 6;     // this should be flat
		this.accuracy = 0;		// bonus percent chance to hit
		this.dodge = 5;			// bonus percent chance to dodge
		

        // Stats
        this.armor = 20;		// 
        this.hp = 20;			// 


        this.mana = {
			offensive : 0,
			defensive : 0,
			support : 0
		};


		// Gems offered at the start of your turn
		this.offeredGems = [];
		this.offeredGemsPicked = 0;
        this.effects = [];
		this.color = "#EFE";	// Color is set when the battle starts

		this.turn_tags = [];	// Tags that are wiped at the end of each turn

		this.TICKRATE = 0.3;

		// Used for texts only
		this.size = 5;			// 0 = small, 5 = average, 10 = very big
		this.strength = 5;		// 0 = weak, 5 = average, 10 = very strong


		// used for NPCS
		this.aiChat = null;
		this.social = 50;		// Chance at each ability to talk
		this.ignore_default_abils = false;		// Don't use default abilities
		this.attack_text_conditions = [];		// Additional conditions for text filtering when you're the attacker
		this.victim_text_conditions = [];		// Additional conditions for text filtering when you're the victim

        this.load(data); 

        return this;
    }



	// Stats

		damage(type, amount, attacker){

			if(typeof amount !== 'object')
				amount = Math.abs(amount);
			
			var text, i;

			var preArmor = this.armor;
			
			var takeDamage =  (type === EffectData.Types.damage || type == EffectData.Types.armorDamage || type === EffectData.Types.hpDamage);
			// Detrimental
			if(takeDamage){
				amount += this.getDmgTakenAdder(attacker);

				this.applyEffectEvent(EffectData.Triggers.takeDamage, [amount], attacker, this);
				attacker.applyEffectEvent(EffectData.Triggers.dealDamage, [amount], attacker, this);
			}


			if(type === EffectData.Types.damage){
				
				this.armor -= amount;
				text = ":TNAME: loses "+amount+" armor.";
				if(this.armor < 0){
					text = ":TNAME: loses ";
					if(Math.abs(this.armor) != amount){
						text+= (amount+this.armor)+" armor and "+Math.abs(this.armor)+" HP.";
					}
					else{
						text+= Math.abs(this.armor)+" HP.";
					}
					this.hp += this.armor;
				}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:text}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.heal){
				this.hp += amount;
				if(this.hp > this.max_hp){amount -= this.hp-this.max_hp;}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: gains "+amount+" HP."}).convert(attacker, this));
			}
			else if(type === EffectData.Types.armorDamage){
				this.armor -= amount;
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: loses "+amount+" armor."}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.hpDamage){
				this.hp -= amount;
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: loses "+amount+" HP."}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.armorHeal){
				this.armor += amount;
				if(this.armor > this.max_armor){amount -= this.armor-this.max_armor;}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: gains "+amount+" armor."}).convert(attacker, this));
			}

			// Mana
			else if(type === EffectData.Types.manaDamage || type === EffectData.Types.manaHeal){

				if(typeof amount !== 'object'){
					console.error("Can't add or subtract mana, amount is not an object", amount);
					return;
				}

				var multi = 1;
				if(type === EffectData.Types.manaDamage)
					multi = -1;

				var texts = [];
				for(i in amount){
					if(!this.mana.hasOwnProperty(i)){
						console.error(i, "is not a valid mana type");
						continue;
					}
					
					var pre = this.mana[i];

					var val = (Math.abs(amount[i])*multi);
					this.mana[i] += val;
					if(this.mana[i] > this.max_mana)
						this.mana[i] = this.max_mana;
					else if(this.mana[i] < 0)
						this.mana[i] = 0;

					var num = this.mana[i]-pre;
					if(num !== 0)
						Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: "+(num > 0 ? 'gains' : 'loses')+" "+Math.abs(num)+" "+i+" mana."}).convert(attacker, this), true);
				}

				
			}

			
			if(preArmor > 0 && this.armor <= 0){
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME:'s "+this.armorSet.name+" was torn off!"}, true, false, false, 'cloth_rip').convert(attacker, this), true);
			}

			// Constraints
			if(this.hp > this.max_hp){this.hp = this.max_hp;}
			else if(this.hp <= 0){
				text = new Text({text:":TNAME: surrenders"});
				Game.Battle.statusTexts.add(attacker, this, text.convert(attacker, this), true, false, false, 'knockout');
				
				this.hp = 0;
			}
			if(this.armor > this.max_armor){this.armor = this.max_armor;}
			else if(this.armor < 0){this.armor = 0;}
			
			for(i in this.mana){
				if(this.mana[i] > this.max_mana)
					this.mana[i] = this.max_mana;
				else if(this.mana[i] < 0)
					this.mana[i] = 0;
			}

			if(takeDamage){
				this.applyEffectEvent(EffectData.Triggers.takeDamageAfter, [amount], attacker, this);
				attacker.applyEffectEvent(EffectData.Triggers.dealDamageAfter, [amount], attacker, this);
			}

			if(amount && type !== EffectData.Types.manaDamage && type !== EffectData.Types.manaHeal)
				this.generateSBT(Math.abs(amount), takeDamage);
			
		}

		// Generates scrolling battle text
		generateSBT(amount, detrimental){
			if(isNaN(amount)){
				return;
			}

			var playerElement = $("div.character[data-uuid="+this.UUID+"]");
			var contentElement = $("#content");
			var pos = playerElement.offset(),
				base = contentElement.offset(),
				height = contentElement.height(),
				width = contentElement.width()
			;
			
			var left = pos.left+playerElement.width()/2 - base.left,
				top = pos.top+playerElement.height()/2 - base.top
			;
			left /= width;
			top /= height;
			
			var elem = $('<div class="SBT'+(!detrimental ? ' good':'')+'" style="left:'+(left*100)+'%; top:'+(top*100)+'%;">'+amount+'</div>');
			// SBT
			$("#content").append(elem);
			setTimeout(function(){
				elem.remove();
			}, 2000);
		}

		isDead(){
			return this.hp <= 0;
		}

		// Defensive stat
		getDodgeFloat(attacker){
			return (this.getStaticValuePoints(EffectData.Types.dodge, attacker, this)+this.dodge)/100;
		}

		// Offensive stat
		getHitFloat(victim){
			return (this.getStaticValuePoints(EffectData.Types.hit, this, victim)+this.accuracy)/100;
		}

		// Defensive stat
		getDmgTakenAdder(attacker){
			return this.getStaticValuePoints(EffectData.Types.damage_boost, attacker, this);
		}

		// Flat stat, does not need to be checked against anyone
		getIsStunned(){
			return this.getEffectsWithStaticValue(EffectData.Types.stun, this, this).length;
		}

		hasEnoughMana(input){

			for(var i in input){
				if(!this.mana.hasOwnProperty(i)){
					console.error(i, "is not a valid mana type");
					continue;
				}
				if(this.mana[i] < input[i])
					return false;

			}
			return true;

		}

		// Gets a static value from effects
		getStaticValuePoints(effectType, attacker, victim){
			var out = 0;
			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				out += fx.getStaticValue(effectType, attacker, victim);
			}
			return out;
		}

		// Same as above but returns all effects with a specific static type
		getEffectsWithStaticValue(effectType, attacker, victim){
			var out = [];
			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.getStaticValueEffects(effectType, attacker, victim).length){
					out.push(fx);
				}
			}
			return out;
		}

		// Gets characters currently taunting you or false
		// Flat stat
		getTaunting(){
			var out = [];
			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.getStaticValueEffects(EffectData.Types.taunt, this, this).length && out.indexOf(fx.getAttacker()) === -1){
					out.push(fx.getAttacker());
				}
			}
			return out;
		}

		pickGem(index){
			if(this.offeredGemsPicked >= 3)
				return false;

			if(index >= this.offeredGems || index < 0)
				return false;

			var gem = this.offeredGems[index];
			if(gem.picked)
				return false;

			var type = gem.type;

			if(this.mana[type] >= this.max_mana && this.hasViablePicker())
				return false;

			this.offeredGems[index].picked = true;
			++this.offeredGemsPicked;
			++this.mana[type];
			if(this.mana[type] > this.max_mana)
				this.mana[type] = this.max_mana;
			
			// No more picks
			if(!this.hasViablePicker())
				this.offeredGemsPicked = 3;
			return true;
		}

		// Checks if at least one picker color is not full
		hasViablePicker(){
			for(var i =0; i<this.offeredGems.length; ++i){
				if(this.offeredGems[i].picked)
					continue;
				if(this.mana[this.offeredGems[i].type] < this.max_mana)
					return true;
			}
			return false;
		}

		manaIsFull(){
			for(var i in this.mana){
				if(this.mana[i] < this.max_mana)
					return false;
			}
			return true;
		}

    
	//
	
	// Tags & RP
        // Returns all tags
        getTags(){
            var out = this.tags.slice();
            // Armor stripped
            if(this.armor <= 0){
                out.push('nude');
            }
            // Get armor tags
            else{
                out = out.concat(this.armorSet.tags);
            }
			out = out.concat(this.race.tags).concat(this.turn_tags);


			for(var i =0; i<this.effects.length; ++i)
				out = out.concat(this.effects[i].tags);

            return out;
        }

		// Accepts a string or array
		addTurnTags(tags){
			if(!tags)
				return;
			if(tags.constructor !== Array)
				tags = [tags];
			
			this.turn_tags = this.turn_tags.concat(tags);
		}

		getGender(){

			var penis = this.hasAnyTag('c_penis'), vagina = this.hasAnyTag('c_vagina'), breasts = this.hasAnyTag('c_breasts');

			if(penis && !vagina && !breasts)
				return 'male';
			if(vagina && breasts && !penis)
				return 'female';
			if(vagina && breasts && penis)
				return 'herm';
			if(penis && breasts && !vagina)
				return 'dickgirl';
			if(!penis && !breasts && vagina)
				return 'cboy';
			
			return 'unknown';

		}

        // Check if any tag of array scan exists 
        hasAnyTag(scan){

			if(scan.constructor !== Array){
				scan = [scan];
			}

            var tags = this.getTags();

            for(var i=0; i<scan.length; ++i){
                if(~tags.indexOf(scan[i])){
                    return true;
                }
            }
            return false;
        }

		getRaceName(){
			return this.race.getName(this.hasAnyTag('c_breasts'));
		}

		// RP Text
		getLabel(type){
			
			type = type.toUpperCase();
			var synonyms = [];
			var pronouns = this.getPronouns();
			
			// Any order
			if(~[":VNAME:", ":TNAME:", ':TARGET:'].indexOf(type)){
				return '%t';
			}
			if(~[':ANAME:', ':ATTACKER:'].indexOf(type)){
				return '%a';
			}
			
			if(~[':ARACE:', ":VRACE:", ":TRACE:"].indexOf(type)){
				return escape(this.getRaceName());
			}

			if(~[':ABREASTS:', ":VBREASTS:", ":TBREASTS:"].indexOf(type)){
				synonyms = ["boobs", "breasts", "tits"];
				if(!this.hasAnyTag("c_breasts")){
					synonyms = ["chest", "torso"];
				}
			}
			if(~[':BUTT:', ':TBUTT:', ':ABUTT:', ':VBUTT:'].indexOf(type)){
				synonyms = ["butt", "hiney", "rump"];
			}

			if(~[':ACLOTHES:', ':VCLOTHES:', ':TCLOTHES:'].indexOf(type)){
				if(this.armorSet && this.armorSet.name){
					return this.armorSet.name.toLowerCase();
				}
				return clothes;
			}

			// No synonyms on its own, fall through
			if(~[':VCROTCHEX:',':ACROTCHEX:',':TCROTCHEX:'].indexOf(type)){
				type = ':CROTCH:';
				if(this.hasAnyTag('c_penis')){type = ':VPENIS:';}
				else if(this.hasAnyTag('c_vagina')){type = ':VVAG:';}
			}
			
			if(~[':APENIS:', ':VPENIS:', ':TPENIS:'].indexOf(type)){
				synonyms = ["penis", "dick", "member", "cock"];
				if(!this.hasAnyTag("c_penis")){
					type = ':CROTCH:';
				}
			}
			if(~[':AVAG:',':VVAG:',':TVAG:',':TVAGINA:',':VVAGINA:',':AVAGINA:'].indexOf(type)){
				synonyms = ["vagina", "pussy", "cunt"];
				if(!this.hasAnyTag("c_vagina")){
					type = ':CROTCH:';
				}
			}
			// Catchall for groins
			if(~[':CROTCH:', ':GROIN:', ':TCROTCH:', ':TGROIN:', ':ACROTCH:', ':AGROIN:'].indexOf(type)){
				synonyms = ["crotch", "groin"];
			}

			if(~[':ABTAG:',':VBTAG:',':TBTAG:'].indexOf(type)){
				synonyms = this.body_tags;
			}

			if(~[':AHE:',":VHE:",":THE:"].indexOf(type)){
				return pronouns[0];
			}
			if(~[':AHIM:', ":VHIM:", ":THIM:"].indexOf(type)){
				return pronouns[1];
			}
			if(~[':AHIS:',":VHIS:",":THIS:"].indexOf(type)){
				return pronouns[2]; 
			}
			
			if(!synonyms.length){
				return "";
			}

			return synonyms[Math.floor(Math.random()*synonyms.length)];

		}

		getPronouns(){
			if(!this.pronouns || this.pronouns.length !== 3){
				// Auto generate
				var out = ["he", "him", "his"];
				if(this.hasAnyTag("c_breasts")){
					if(this.hasAnyTag('c_vagina') && this.hasAnyTag('c_penis'))
						out = ["shi", "hir", "hir"];
					else
						out = ["she", "her", "her"];
				}

				return out;
			}
			return this.pronouns;
		}

		// Returns a (link?). Use this whenever getting text in a battle
		getName(){
			return '<span style="color:'+this.color+'">'+escape(this.name)+'</span>';
		}

		getImage(){
			if(!this.image)
				return this.race.default_icon;

			var image = this.image;

			if(this.image.substr(0,6) !== 'https:'){
				if(this.image.substr(0,5) === 'http:')
					image = 'https'+image.substr(4);
				else
					image = 'https://'+image;
			}
			return image;
		}


    //
	
	// Gear

		ownsArmor(id){
			if(~this.armor_unlocked.indexOf(id))
				return true;
			return false;
		}

		unlockArmor(id){
			if(this.ownsArmor(id))
				return true;
			if(!this.equipArmor(id))
				return false;
				
			this.armor_unlocked.push(id);
			this.save();
		}

		equipArmor(id, save){
			var armor = Armor.get(id);
			if(armor === false)
				return false;
			
			this.armorSet = armor;

			if(save)
				this.save();
			return true;
		}

	//

	// Abilities
		// Returns true if you have as many abilities as you can hold
		abilitiesFull(){
			var n = 0;
			for(var i =0; i<this.abilities.length; ++i){
				var ability = this.abilities[i];
				if(~Ability.DEFAULTS.indexOf(ability.id))
					continue;
				if(++n >= Character.MAX_ABILITIES){
					return true;
				}
			}
			return false;
		}

        addAbility(id, save){

			

			var ability = null;
            if(id.constructor === Ability)
				ability = id;
			else{
				ability = Ability.get(id);
			}
			if(!ability){
				var pos = this.abilities_unlocked.indexOf(id);
				if(~pos){
					this.abilities_unlocked.splice(pos, 1);
				}
                return false;
            }

			if(id.constructor !== Ability)
				ability = ability.clone();

			if(Ability.DEFAULTS.indexOf(id) === -1 && this.abilities_unlocked.indexOf(ability.id) === -1 && ability.id){
				// Add to unlocks
				this.abilities_unlocked.push(ability.id);
				save = true;
			}


            if(!this.hasAbility(ability.id, true) && ! this.abilitiesFull()){
            	ability.parent = this;
            	this.abilities.push(ability);
			}

			if(save){
				this.save();
			}
			return true;
        }

		addAbilities(ids){
			for(var i =0; i<ids.length; ++i)
				this.addAbility(ids[i]);
		}

		removeAbility(id){
			// Can't remove defaults
			if(~Ability.DEFAULTS.indexOf(id)){
				return false;
			}

			for(var i =0; i<this.abilities.length; ++i){
				if(this.abilities[i].id === id){
					this.abilities.splice(i, 1);
					this.save();
					return true;
				}
			}

			
			return false;
		}

		// checks if user has an ability, either unlocked or active
        hasAbility(id, active_only){
            for(var i=0; i<this.abilities.length; ++i){
                if(this.abilities[i].id === id || (~this.abilities_unlocked.indexOf(id) && !active_only)){
                    return true;
                }
            }
            return false;
        }


        getAbilityByUuid(uuid){
            for(var i = 0; i<this.abilities.length; ++i){
                if(this.abilities[i].UUID === uuid){
                    return this.abilities[i];
                }
            }
            return false;
        }

		// Checks an array of IDs
		hasOneAbility(arr){
			for(var i =0; i<arr.length; ++i){
				if(this.hasAbility(arr[i])){
					return true;
				}
			}
			return false;
		}

		getUnlockableAbilities(){
			var out = [];
			var generic = Ability.search({playable:true});
			
			for(var i =0; i<generic.length; ++i){
				if(!this.hasAbility(generic[i].id)){
					out.push(generic[i]);
				}
			}
			return out;

		}

	//

	// Experience, leveling & money
		getFreePoints(){
			if(!this.getUnlockableAbilities())
				return 0;
			return this.unspent_points;
		}

		isMaxLevel(){
			if(this.getUnlockableAbilities().length-this.unspent_points <= 0){
				return true;
			}
			return false;
		}

		getLevel(){
			return this.unspent_points+this.abilities_unlocked.length-1; // You start off with 2 base abilities
		}

		addExperience(amount){

			if(this.isMaxLevel()){
				return;
			}

			this.experience+=amount;
			Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: gained "+amount+" experience."}).convert(this, this));

			var gainedLevel = false;
			while(this.experience >= this.getMaxExperience() && !this.isMaxLevel()){
				++this.unspent_points;

				gainedLevel = true;
				this.experience -= this.getMaxExperience();
				Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: gained a level! Welcome to level "+this.getLevel()+"!"}).convert(this, this));
			}

			if(this.isMaxLevel())
				this.experience = 0;
			
			if(gainedLevel)
				Game.playSound('levelup');

			this.save();
		}

		getMaxExperience(){
			var out = this.getLevel();
			if(out>5){
				out = 5;
			}
			return out;
		}

		addMoney(amount, save){
			if(amount < 0 && Math.abs(amount) > this.cash){
				return false;
			}

			if(amount > 0)
				Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: was rewarded "+amount+" √ê."}).convert(this, this), false, false, true);

			this.cash+= amount;
			if(save)
				this.save();
			return true;
		}



	// 

	// DOM
		inspect(){
			var hsc = Jasmop.Tools.htmlspecialchars;
			var html = '<div id="characterInspect">';
				html+= '<img class="icon" src="'+this.getImage()+'" />';
				html+= '<h1>'+hsc(this.name)+'</h1>';
				html+= '<p class="race">Level '+this.getLevel()+' '+hsc(this.getGender())+' '+hsc(this.race.getName())+' - '+hsc(this.affinity.toUpperCase())+' Affinity</p>';
				html+= '<p class="description">'+hsc(this.description)+'</p>';
				html+= '<p class="armor">'+(this.armor ? 'Wearing '+hsc(this.armorSet.name) : 'Nude')+'</p>';
				if(Netcode.isHosting() && this.UUID !== Game.player.UUID && this.is_pc){
					html+= '<input type="button" class="kickPlayer" data-uuid="'+hsc(this.UUID)+'" value="Kick" />';
				}
				html+= '<div class="clear"></div>';
			html+= '</div>';

			Jasmop.Overlay.set(html);

			var th = this;
			$("#overlay input.kickPlayer").on('click', function(){
				Netcode.kick(th.socket_id);
			});

		}
	//


	// Effects
		removeEffect(uuid, silent){
			for(var i =0; i<this.effects.length; ++i){
				if(this.effects[i].UUID === uuid){
					var fx = this.effects[i];
					if(fx.fadeText && !silent){
						var text = new Text({text:fx.fadeText});
						Game.Battle.statusTexts.add(fx.getAttacker(), this, text.convert(fx.getAttacker(), fx.getVictim()), !fx.detrimental);
					}
					this.effects.splice(i, 1);
					return;
				}
			}
		}

		removeEffectsByIds(ids, silent){
			for(var i =0; i<this.effects.length && this.effects.length; ++i){
				if(~ids.indexOf(this.effects[i].id)){
					this.removeEffect(this.effects[i].UUID, silent);
					--i;
				}
			}
		}

		applyEffectEvent(evt, data, attacker, victim){
			var fx = this.effects.slice();		// Makes sure effects get removed properly
			for(var i=0; i<fx.length; ++i){
				fx[i].on(evt, data, attacker, victim);
			}
		}

		hasEffectByCaster(id, casterUUID){
			for(var i=0; i<this.effects.length; ++i){
				if(this.effects[i].id === id && this.effects[i]._attacker === casterUUID){
					return this.effects[i];
				}
			}
			return false;
		}

		dispel(beneficial, max){

			var all = this.effects.slice();
			for(var i =0; i<all.length && (max > 0 || max === -1); ++i){
				var fx = all[i];
				if(
					(all.beneficial && beneficial) ||
					(!all.beneficial && !beneficial)
				){
					this.removeEffect(fx.UUID, false);
					--max;
				}
			}

		}


    //
	
	// Event listeners
        onLoaded(){

			var clone = this.abilities.slice();

			if(this.is_pc){
				this.max_hp = 20;
				this.max_armor = 20;
				this.dodge = 5;
			}
			// Import abilities
			this.abilities = [];
			for(var i =0; i<clone.length; ++i){

				if(clone[i].constructor === Ability)
					this.addAbility(clone[i].id);
				else if(clone[i].constructor === Object)
					this.addAbility(new Ability(clone[i], this));
				else
					this.addAbility(clone[i]);
					
			}

			this.abilities_unlocked = this.abilities_unlocked.filter(function(el, index, arr) {
				return index == arr.indexOf(el);
			});

			if(typeof this.mana !== 'object'){
				this.mana = {
					offensive : 0,
					defensive : 0,
					support : 0
				};
			}

			if(!this.mana.hasOwnProperty('offensive'))
				this.mana.offensive = 0;
			if(!this.mana.hasOwnProperty('defensive'))
				this.mana.defensive = 0;
			if(!this.mana.hasOwnProperty('support'))
				this.mana.support = 0;
			

			// Add required abilities
			if(!this.ignore_default_abils){
				var add = Ability.DEFAULTS;
				for(i=0; i<add.length; ++i){
					this.addAbility(add[i]);
				}
			}
			
			// Handle other classes

			if(this.race.constructor !== Race){
				if(this.race.constructor === Object)
					this.race = new Race(this.race);
				else
					this.race = Race.get(this.race);
			}

			if(this.armorSet.constructor !== Armor){
				if(this.armorSet.constructor === Object)
					this.armorSet = new Armor(this.armorSet);
				else
					this.armorSet = Armor.get(this.armorSet);
			}


			// Effects are present when loaded from netgame
			for(i=0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.constructor === Object)
					this.effects[i] = new Effect(this.effects[i]);
			}

			// Use species as a name if name is not defined
			if(!this.name){
				this.name = this.race.name_male;
			}

        }

		onAdd(){
			DB.sort("Character", "name");
		}

        onClone(){
            for(var i=0; i<this.abilities.length; ++i){
                this.abilities[i] = this.abilities[i].clone();
                this.abilities[i].parent = this;
            }
            this.armorSet = this.armorSet.clone();
        }

        onBattleStart(){

			for(var i in this.mana){
				this.mana[i] = 0;
			}
			
            this.hp = this.max_hp;
            this.armor = this.max_armor;
            this.effects = [];

			this.aiChat = new AIChat(this);

			this.turn_tags = [];			

			for(i =0; i<this.abilities.length; ++i){
				this.abilities[i].onBattleStart();
			}
        }

		// A battle has been won
		onVictory(){
			this.addMoney(5);
			this.addExperience(1); // Saves
		}

        onTurnStart(){

			// Add your spec specific mana
			for(var i in this.mana){
				if(
					(i === 'offensive' && this.affinity === Ability.AffinityOffensive) ||
					(i === 'defensive' && this.affinity === Ability.AffinityDefensive) ||
					(i === 'support' && this.affinity === Ability.AffinitySupport)
				){
					++this.mana[i];
				}
				if(this.mana[i] > this.max_mana)
					this.mana[i] = this.max_mana;	
			}


			// This has to go before next. Raise turn start event, attacker and victim are this.
			this.applyEffectEvent(EffectData.Triggers.turnStart, [], this, this);

			for(i=0; i<this.abilities.length; ++i){
				this.abilities[i].onTurnStart();
			}

			// Generate offered gems:
			this.offeredGems = [];
			var random = ["offensive", "defensive", "support"];
			for(i=0; i<5; ++i){
				this.offeredGems.push(
					{type: random[Math.floor(Math.random()*random.length)], picked:false}
				);
			}
			this.offeredGemsPicked = 0;
        }

        onTurnEnd(){
			// Attacker and victim are the same
            this.applyEffectEvent(EffectData.Triggers.turnEnd, [], this, this);
			this.turn_tags = [];
        }

	//
	
	// Validation

		// Validates global text conditions for this character. Can be used to make a character straight for an instance.
		// Does not affect abilities, only texts
		validateAttackerConditions(victim, ability, success, verbose){
			for(var i =0; i<this.attack_text_conditions.length; ++i){
				if(!this.attack_text_conditions[i].validate(this, victim, ability, success, verbose))
					return false;
			}
			return true;
		}
		validateVictimConditions(attacker, ability, success, verbose){
			for(var i =0; i<this.victim_text_conditions.length; ++i){
				if(!this.victim_text_conditions[i].validate(attacker, this, ability, success, verbose))
					return false;
			}
			return true;
		}
		

	//

	// Export - Import can just use new Character
		export(){
			var out = {
				UUID : this.UUID,
				id : this.id,
				name : this.name,
				description : this.description,
				image : this.image,
				abilities : this.abilities.map(function(val){return val.id;}),
				tags : this.tags,
				pronouns : this.pronouns,
				race : this.race.id,
				body_tags : this.body_tags,
				armorSet : this.armorSet.id,
				modified : this.modified,
				affinity : this.affinity,
				experience : this.experience,
				unspent_points : this.unspent_points,
				abilities_unlocked : this.abilities_unlocked,
				cash : this.cash,
				armor_unlocked : this.armor_unlocked,
				is_pc : this.is_pc,
				size : this.size,
				strength : this.strength
			};
			return out;
		}

		/*
			Needed exports in subclasses:
			- Ability
			- Race
			- Effects
		*/
		// Netgame export for the host to send to all other players
		hostExportFull(){
			var out = this.export();
			delete out.id;
			
			out.socket_id = this.socket_id;
			out.abilities = this.abilities.map(function(val){
				return val.export();
			});
			out.race = this.race.export();
			out.armorSet = this.armorSet.export();
			out.effects = this.effects.map(function(val){return val.export();});
			out.armor = this.armor;
			out.hp = this.hp;
			out.mana = this.mana;
			out.color = this.color;
			out.offeredGems = this.offeredGems;
			out.offeredGemsPicked = this.offeredGemsPicked;
			out.turn_tags = this.turn_tags;
			if(Netcode.hosting){
				out.team = this.team;
			}
			
			return out;
		}


		// Puts to DB
		save(force){
			// This is not the active player
			if(this !== Game.player && !force)
				return;
			this.modified = Date.now();
			return IDB.put('characters', this.export());
		}

}
Character.TEAM_PC = 0;
Character.TEAM_NPC = 1;

Character.MAX_ABILITIES = 5;

    



// Armor set
class Armor extends Asset{

    constructor(data){
        super();

        this.id = '';
        this.name = '';
        this.description = '';
        this.tags = [];
		this.in_store = true;

        this.load(data); 

        return this;
    }

	export(){
		return {
			id : this.id,
			name : this.name,
			description : this.description,
			tags : this.tags,
			in_store : this.in_store
		};
	}

    onClone(){

    }

}







// Abilities
class Ability extends Asset{



    constructor(data, parent){
        super();

        this.parent = parent;
        this.id = '';   // Should be unique
        this.name = '';
        this.description = '';
        this.manacost = {
			offensive : 0,
			defensive: 0,
			support : 0
		};
        this.conditions = [];
        this.effects = [];				// [[Effect, stacks]...] || [Effect...]
        this.cooldown = 1;
		this.detrimental = true;
		this.ai_tags = [];				// Tags for AI, ex healing
		this.allow_dead = false;		// Usable on dead
		this.playable = false;		
		this.icon = '';					// Should be an SVG	
		this.charged = 0;				// Num turns it takes to charge it

        // Gameplay values
        this._cooldown = 0;
		this._charged = 0;				// Num turns until it should execute
		this._charge_targs = [];		// Targets it should hit once it executes

        this.load(data); 

        return this;
    }

	// Netgame export
	export(){


		return {
			UUID : this.UUID,
			id : this.id,
			name : this.name,
			description : this.description,
			manacost : this.manacost,
			conditions : this.conditions.map(function(val){ return val.export(); }),
			effects : this.effects.map(function(val){
				if(val.constructor !== Array){
					val = [val, 1];
				}
				val = val.slice();
				val[0] = val[0].export();
				return val;
			}),
			cooldown : this.cooldown,
			detrimental : this.detrimental,
			ai_tags : this.ai_tags.slice(),
			allow_dead : this.allow_dead,
			playable : this.playable,
			icon : this.icon,
			_cooldown : this._cooldown
		};
	}

	onLoaded(){
		var i;

		if(typeof this.mana !== "object"){
			this.mana = {
				offensive : 0,
				defensive : 0,
				support : 0 
			};
		}

		if(!this.mana.hasOwnProperty('offensive'))
			this.mana.offensive = 0;
		if(!this.mana.hasOwnProperty('defensive'))
			this.mana.defensive = 0;
		if(!this.mana.hasOwnProperty('support'))
			this.mana.support = 0;
		
		
		for(i=0; i<this.effects.length; ++i){
			var val = this.effects[i];
			if(val.constructor !== Array){
				val = [val, 1];
			}
			val[0] = new Effect(val[0]);
		}
		
		for(i=0; i<this.conditions.length; ++i){
			this.conditions[i] = new Condition(this.conditions[i]);
		}
	}


    // Returns an array of viable players for this spell or false if none
    usableOn(targ, verbose, allowError, isCharged){
        if(targ.constructor !== Array){
            targ = [targ];
        }

        var out = [], i;

		// Currently charging
		if(this._charged){
			return false;
		}

        if(this.parent.hp <= 0){ 
			if(allowError)
				Jasmop.Errors.addErrors('Invalid target');
			
			if(verbose){console.log(this.name, "fail because HP");} 
			return false; 
		}

		// Charge hits don't cost mana
		if(!isCharged){
			var cost = this.getManaCost();
			for(i in cost){
				if(this.parent.mana[i] < cost[i]){
					if(allowError)
						Jasmop.Errors.addErrors('Insufficient mana');

					if(verbose){console.log(this.name, "fail because mana", this.parent);} 
					return false;
				}
			}
		}

		if(this._charged){
			if(allowError)
				Jasmop.Errors.addErrors('That ability is charging');
			if(verbose){console.log(this.name, "fail because charging");} 
			return false; 
		}

        if(this._cooldown){ 

			if(allowError)
				Jasmop.Errors.addErrors('That ability is not ready yet');

			if(verbose){console.log(this.name, "fail because Cooldown");} 
			return false; 
		}
		if(this.parent.getIsStunned()){

			if(allowError)
				Jasmop.Errors.addErrors('You are incapacitated');

			if(verbose){console.log(this.name, "fail because stun");} 
			return false; 
		}
        
		// Manage taunt
		var taunts = this.parent.getTaunting(), t = [];

		// Calculate taunts. Should not work against buffs.
		if(taunts.length && this.detrimental){
			t = [];
			for(i = 0; i<taunts.length; ++i){
				if(~targ.indexOf(taunts[i])){
					t.push(taunts[i]);
				}
			}
			targ = t;
		}

		if(verbose)
			console.log("Scanning", this.name, "against", targ.length, "players");
        
		for(var x =0; x<targ.length; ++x){

            t = targ[x];

			if(t.isDead() && !this.allow_dead)
				continue;

			var success = true;
            for(i=0; i<this.conditions.length && success; ++i){

                var cond = this.conditions[i];
                if(!cond.validate(this.parent, t)){
					if(verbose){
						console.log(this.name, "fail because condition", cond, 'against', t.name);
					}
                    success = false;
                }
            }

            // At least one targ was accepted
            if(success){
				if(verbose){
					console.log(this.name, "Success against", t.name);
				}
                out.push(t);
            }


        }

        if(!out.length){
            return false;
        }
        return out;
    }

	// Returns an array containing players successfully hit
    useAgainst(targ, verbose, chargeHit){
		if(targ.constructor !== Array){
			targ = [targ];
		}


		var usr, successes = [], attacker = this.parent, i, text;
		
		// Filter out usable
		targ = this.usableOn(targ, false, false, chargeHit);

		if(this.charged){
			console.log("This is charged. ChargeHit:", chargeHit, "targs:", targ);
		}

		// No viable targets
		if(!targ){
			console.error("No viable targets");
			return [];
		}

		
		// Handle charge
		if(this.charged && !chargeHit){

			this._charged = this.charged;
			this._charge_targs = targ;
			
			var txt = ":ATTACKER: charges :ABIL: at :TARGET:!";
			if(targ.length > 1)
				txt = ":ATTACKER: charges :ABIL:!";

			text = new Text({text:txt});
			Game.Battle.addToBattleLog(this.parent, targ[0], text.convert(this.parent, targ[0], this), "rptext ability", false, 'charge');

		}

		// Non-charged ability or charge execs
		else{

			for(usr = 0; usr<targ.length; ++usr){

				var t = targ[usr];
				// Dodge, invul etc
				var fail = false;

				// Check dodge
				if(this.detrimental){

					var d = t.getDodgeFloat(attacker)-this.parent.getHitFloat(t);
					if(verbose)
						console.log(attacker.name, "hit chance against", t.name, d);
					if(Math.random() < d){
						fail = true;
					} 

				}

				// Generate the text first
				text = Text.generate(this.parent, t, this, !fail);
				Game.Battle.statusTexts.capture = true;				// Make sure status texts end up last 


				// Add effects
				if(!fail){

					for(i =0; i<this.effects.length; ++i){
						var fx = this.effects[i];
						if(fx.constructor !== Array){fx = [fx];}

						fx[0].useAgainst( this.parent, t, (fx[1] || 1) );
					}

					// Hit visual
					var visual = (this.detrimental ? 'hitDetrimental' : 'hitBeneficial');
					$("div.character[data-uuid="+t.UUID+"]").toggleClass("hitDetrimental hitBeneficial", false);


					setTimeout(function(){
						$("div.character[data-uuid="+t.UUID+"]").toggleClass(visual, true);
					}, 10);
					
				}

				// Run the original effects before raising this event.
				if(this.detrimental){
					// I tried to use a detrimental ability on t, regardless of if it failed or not. Attacker is parents and victim is t
					t.applyEffectEvent(EffectData.Triggers.attacked, [], this.parent, t);

					this.parent.addTurnTags('recently_attacking');
					t.addTurnTags('recently_attacked');
					if(fail){
						t.addTurnTags('recently_missed');
					}
				}

				


				

				var out = text.convert(this.parent, t, this);
				var sound = text.sound;
				if(!sound)
					sound = 'shake';
				var textblock = out;

				Game.Battle.addToBattleLog(this.parent, t, textblock, "rptext ability", false, sound);
				Game.Battle.statusTexts.output();	// This flushes queued battle texts and ends capture

				

				if(!fail){
					successes.push(t);

					if(!this.parent.is_pc && successes.length === 1)
						this.parent.aiChat.get(AIChat.Events.ability, text, this.parent, t, this);

				}
			}

			// Add cooldown
			this._cooldown = this.cooldown;
		}

		// Don't consume mana if it was a charge hit, but do if it was a charge start
		if(!chargeHit){
			var cost = this.getManaCost();
			for(i in cost){
				this.parent.mana[i] -= cost[i];
			}
		}

		return successes;
    }

    // Events
    onClone(){
        this._cooldown = 0;
        var fx = [], i;

        for(i=0; i<this.effects.length; ++i){
			// effects can be either arrays or single objects, this converts all of them into arrays
			if(this.effects[i].constructor !== Array){
				this.effects[i] = [this.effects[i]];
			}
			var arr = this.effects[i].slice();
			arr[0] = arr[0].clone();
            fx.push(arr);
        }
        this.effects = fx;
        fx = [];
        for(i=0; i<this.conditions.length; ++i){
            fx.push(this.conditions[i].clone());
        }
        this.conditions = fx;
    }

    onTurnStart(){
        --this._cooldown;
		if(this._cooldown < 0){
            this._cooldown = 0;
        }
		if(this._charged){
			--this._charged;
			if(!this._charged){
				console.log("Using against", this._charge_targs);
				this.useAgainst(this._charge_targs, false, true);
			}
		}
    }

	onBattleStart(){
		this._cooldown = 0;
	}

	getManaCost(){
		// You might wanna check if this is a punishment before returning any custom val here. Otherwise punishments will fail because mana
		return this.manacost;
	}

	getButton(highlight){
		var out = '<div class="ability button '+(highlight ? ' highlighted ' : '')+'" data-uuid="'+this.UUID+'" data-id="'+Jasmop.Tools.htmlspecialchars(this.id)+'">';
				
			// Main presentation
			if(this.icon){
				out+= '<img class="icon" src="media/effects/'+this.icon+'" />';
			}

			out+= Jasmop.Tools.htmlspecialchars(this.name);
			out+= '<span class="cooldown"></span>';

			// Tooltip
			out+= '<span class="tooltip info">'+Jasmop.Tools.htmlspecialchars(this.description);
				out+= '<hr />';

				for(var i in this.manacost){
					if(this.manacost[i] <= 0)
						continue;
					out+= '<div class="manacost '+Jasmop.Tools.htmlspecialchars(i)+'"><div class="bg" /><p>'+this.manacost[i]+'</p></div>';
				}
				

			out+= '</span>';

		out+= '</div>';

		return out;
	}
}

Ability.AffinityOffensive = 'OFFENSIVE';
Ability.AffinityDefensive = 'DEFENSIVE';
Ability.AffinitySupport = 'SUPPORT';



// Effects
class Effect extends Asset{



    constructor(data){
        super();

		this.id = '';
		this.max_stacks = 1;
        this.duration = 0;
        this.detrimental = true;
        this.events = [];						// EffectData
		this.fadeText = "";
		this.applyText = "";
		this.target = Game.Consts.TARG_VICTIM;
		this.icon = '';
		this.tags = [];							// Custom tags to apply to the victim

		this.name = '';
		this.description = '';

        this._duration = 0;
        this._attacker = null;
        this._victim = null;
		this._stacks = 1;
        

        this.load(data); 

        return this;
    }

	// Netgame export
	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			max_stacks : this.max_stacks,
			duration : this.duration,
			detrimental : this.detrimental,
			events : this.events.map(function(val){return val.export();}),
			fadeText : this.fadeText,
			applyText : this.applyText,
			target : this.target,
			icon : this.icon,
			tags : this.tags.slice(),
			name : this.name,
			description : this.description,
			_duration : this._duration,
			_attacker : this._attacker,
			_victim : this._victim,
			_stacks : this._stacks
		};
	}

	getVictim(){return Netcode.getCharacterByUuid(this._victim);}
	getAttacker(){return Netcode.getCharacterByUuid(this._attacker);}

	onLoaded(){
		for(var i =0; i<this.events.length; ++i)
			this.events[i] = new EffectData(this.events[i], this);
	}


	// Generic
    useAgainst(attacker, victim, stacks){

		if(victim.isDead()){
			return false;
		}

		// Creates a specific clone of this
        var clone = this.clone();
        clone._attacker = attacker.UUID;
        clone._victim = victim.UUID;

		// A self cast
		if(this.target === Game.Consts.TARG_ATTACKER){
			clone._victim = attacker.UUID;
		}

        clone._duration = this.duration;
		clone._stacks = stacks || 1;
		
        // Long term effect
        if(clone.duration){

			// See if effect exists by the caster, in that case, grab stacks from it
			var fx = clone.getVictim().hasEffectByCaster(this.id, clone._attacker);
			if(fx){
				clone._stacks += fx._stacks;
				clone.getVictim().removeEffectsByIds(this.id, true); // Silently remove the old effect
			}

          	clone.getVictim().effects.push(clone);
        }

		// Make sure stacks don't overflow
		if(clone._stacks > clone.max_stacks){
			clone._stacks = clone.max_stacks;
		}
		
		if(this.applyText){
			var text = new Text({text:this.applyText});
			Game.Battle.statusTexts.add(clone.getAttacker(), clone.getVictim(), text.convert(clone.getVictim(), clone.getVictim()), this.detrimental);
		}

		clone.on(EffectData.Triggers.apply, [], attacker, victim);
		if(!clone.duration){
			clone.on(EffectData.Triggers.remove, [], victim, victim);
		}

    }

	// Specific
	remove(triggerer){

		// Removes from victim
		this.on(EffectData.Triggers.remove, [], triggerer, this._victim);

		this.victim.removeEffect(this.UUID);

	}

	

	// Generic event listener
    on(evtName, data, attacker, victim){


		for(var i =0; i<this.events.length; ++i){
			var evt = this.events[i];
			if(evt.hasTrigger(evtName, data, attacker, victim)){
				this.runEvt(evt);
			}
		}


		// Using _victim and _attacker directly is fine here because of string UUID comparison
		if(
			// Self effects tick on turn start
			(evtName === EffectData.Triggers.turnStart && this._attacker === this._victim) ||
			// Other player effects tick on turn end
			(evtName === EffectData.Triggers.turnEnd && this._attacker !== this._victim)
		){
			--this._duration;
			if(this._duration <= 0){
				this.getVictim().removeEffect(this.UUID);
			}
		}

    }

	// Runs an event
	runEvt(evt, triggerer, data){

		var fxs = evt.effects.slice();
		var attacker = this.getAttacker();
		var victim = this.getVictim();

		if(fxs.target === Game.Consts.TARG_ATTACKER){
			attacker = this.getVictim();
			victim = this.getAttacker();
		}

		for(var i=0; i<fxs.length; ++i){



			var fx = fxs[i];
			if(fx.constructor !== Array){fx = [fx];}
			else{ fx = fx.slice(); }

			var type = fx[0].toLowerCase();
			fx.splice(0,1);

			// Standard damage types
			if(
				type === EffectData.Types.damage ||
				type === EffectData.Types.heal ||
				type === EffectData.Types.armorDamage ||
				type === EffectData.Types.hpDamage ||
				type === EffectData.Types.armorHeal ||
				type === EffectData.Types.manaHeal ||
				type === EffectData.Types.manaDamage				
			){
				victim.damage(type, fx.shift(), attacker);
			}

			if(type === EffectData.Types.remByID){
				victim.removeEffectsByIds(fx);
			}
			if(type === EffectData.Types.remThis){
				victim.removeEffect(this.UUID);
			}

			if(type === EffectData.Types.dispel){
				var ben = fx[0] || false;
				var max = fx[1] !== undefined ? +fx[1] : -1;
				victim.dispel(ben, max);
			}
			
		}


	}

	onClone(){
		var evts = [];
		for(var i =0; i<this.events.length; ++i){
			var e = this.events[i].clone();
			e.parent = this;
			evts.push(e);
		}
		this.events = evts;
		this.tags = this.tags.slice();
	}

	// Gets a flat value such as dodge
	getStaticValue(type, attacker, victim){
		var out = 0;
		var fxs = this.events;
		for(var i=0; i<fxs.length; ++i){
			out+= fxs[i].getStaticValue(type, attacker, victim);
		}
		return out;
	}

	// Checks if a flat value such as taunt exists, and returns those values
	getStaticValueEffects(type, attacker, victim){
		var out = [];
		var fxs = this.events;
		for(var i=0; i<fxs.length; ++i){
			if(fxs[i].hasStaticValue(type, attacker, victim))
				out.push(fxs[i]);
		}
		return out;
	}

}

class EffectData extends Asset{

    constructor(data, parent){
        super();

        // Types are case insensitive
        this.triggers = [];         				// [[type, arg1, arg2...]...] || [type...]
        this.effects = [];          				// [[type, arg1, arg2...]...] || [type...]
		this.target = Game.Consts.TARG_VICTIM;
		this.parent = parent;
		this.victim_on_attacker = 0;				// 0 = either, 1 = this.parent._victim raised event against this.parent._attacker, -1 = this.parent._attacker raised event against this.parent._victim
		

        this.load(data);
    }

	export(){
		return {
			triggers : this.triggers.slice(),
			effects : this.effects.slice(),
			target : this.target,
			victim_on_attacker : this.victim_on_attacker
		};
	}

	onLoaded(){
		for(var i =0; i<this.effects.length; ++i){
			if(this.effects[i].constructor !== Array){
				this.effects[i] = [this.effects[i]];
			}
		}
	}

	// Validate victim on attacker. Attacker is the one who raised the event, victim is the victim of the event (if applicable)
	validateVoA(attacker, victim){
		// No preference set
		if(+this.victim_on_attacker === 0 || isNaN(this.victim_on_attacker))
			return true;
		

		if(
			// Victim is the person who added this effect
			(+this.victim_on_attacker > 0 && victim.UUID === this.parent._attacker) ||
			// Attacker is the person who added this effect
			(+this.victim_on_attacker < 0 && attacker.UUID === this.parent._attacker)
		){
			return true;
		}

		return false;
	
	}

	hasTrigger(evtName, data, attacker, victim){

		evtName = evtName.toLowerCase();
		var triggers = this.triggers.slice();
		var effects = this.effects.slice();

		// Victim on attacker limits
		if(!this.validateVoA(attacker, victim))
			return false;

		for(var i =0; i<triggers.length; ++i){
			var tr = triggers[i];
			if(tr === undefined){
				console.error("Invalid trigger in effectData", this);
			}

			if(tr.constructor !== Array){
				tr = [tr];
			}

			tr = tr.slice(); // Copies the array

			var type = tr[0];
			tr.splice(0,1);		// Tr is now args

			if(type === evtName){

				// Todo: Validate tr against data
				return true;

			}

		}

		return false;
	}

	// get a static value such as dodge. Obviously does not work when this has a trigger
	getStaticValue(type, attacker, victim){

		if(!this.validateVoA(attacker, victim)){
			//console.error("VoA validation failed", "attacker was", attacker.name, "victim", victim.name, "parent", this.parent, "VoA", this.victim_on_attacker);
			return 0;
		}

		if(this.triggers.length){return 0;}
		var out = 0;
		for(var i =0; i<this.effects.length; ++i){
			var fx = this.effects[i];

			// Static values should have at least 1 parameter
			if(fx.length < 2 || isNaN(fx[1]) || fx[0] !== type){
				continue;
			}
			

			out+= fx[1];
		}
		return out;
	}

	// Checks if a static value exists in this effect
	hasStaticValue(type, attacker, victim){

		if(!this.validateVoA(attacker, victim))
			return 0;

		if(this.triggers.length){return false;}

		for(var i =0; i<this.effects.length; ++i){
			var fx = this.effects[i];
			if(fx[0] === type){
				return true;
			}
		}
		return false;
	}

}

// A list of possible triggers. Case insensitive
EffectData.Triggers = {
    apply : 'apply',    // Raised when the effect is added
	remove : 'remove',
    turnStart : "turnstart",			// Raised on turn start
    turnEnd : "turnend",				// Raised on turn end 
    takeDamage : "takedamage",			// *Raised before you take any damage
    dealDamage : "dealdamage",			// *Raised before you successfully deal damage
	takeDamageAfter : "takedamageafter",			// *Raised after you take any damage
    dealDamageAfter : "dealdamageafter",			// *Raised after you successfully deal damage
	attacked : "attacked",				// Raised when receiving an attack, no matter if it hit or not
};

EffectData.Types = {
    damage : "dmg",                     // (int)points - Straight up damage
    heal : "heal",                      // (int)points - HP healing
    armorDamage : "ardmg",              // (int)points - Damage only armor
	hpDamage : "hpdmg",              	// (int)points - Damage only hp
	armorHeal : "arheal",              	// (int)points - Heal only armor
	dodge : "dodge",					// (int)percent - Grants a chance to dodge a detrimental effect
	remByID : "rembyid",				// (str)id1, id2... - Removes an effect by ID
	remThis : "remthis",				// void - Removes this effect
	hit : "hit",						// (int)percent - Increases or decreases hit chance
	damage_boost : "dmgboost",			// (int)dmg - Whenever target takes damage, this amount of point is added
	taunt : "taunt",					// void - Characters affected by taunt can only target the characters that taunted
	stun : "stun",						// void - Prevents character from taking action
	dispel : "dispel",					// (bool)beneficial = false, (int)max = -1 - Removes one or more effects
	manaDamage : "manadmg",				// [{offensive|defensive|support:(int)val}] - Remove mana
	manaHeal : "manaheal",				// [{offensive|defensive|support:(int)val}] - Add mana
};



// Conditions
// This class expects arguments when instantiated
class Condition extends Asset{

	constructor(data){
		
		super();

		this.type = "SELF";
		this.data = [];
		this.target = Game.Consts.TARG_VICTIM;     // If this is Game.TARG_ATTACKER, validate will validate
		this.inverse = false;						// Inversese the condition

		this.load(data);
		return this;
	}

	export(){
		return {
			type : this.type,
			data : this.data.slice(),
			target : this.target,
			inverse : this.inverse
		};
	}

	onLoaded(){
		this.type = this.type.toUpperCase();
	}

	// Validates all
	validate(attacker, victim, ability, success, verbose){

		var a = attacker, b = victim;
		if(this.target === Game.Consts.TARG_ATTACKER){
			// Reverse
			a = victim;
			b = attacker;
		}

		var att = this.pvtValidate(a, b, ability, success);
		if(this.inverse)
			att = !att;

		if(att !== true){
			if(verbose){
				console.log(this.type, this.data, "failed", a, b, ability, success);
			}
			return false;
		}


		return true;
	}

	// Validates a single condition
	pvtValidate(attacker, victim, ability, success){
		var i;

		// Compare both
		if(this.type === Condition.FRIEND && attacker.team !== victim.team){
			return false;
		}
		if(this.type === Condition.ENEMY && attacker.team === victim.team){
			return false;
		}
		if(this.type === Condition.SELF && attacker.UUID !== victim.UUID){
			return false;
		}
		
		if(this.type === Condition.STRONGER_THAN && attacker.strength < victim.strength)
			return false;
		if(this.type === Condition.WEAKER_THAN && attacker.strength > victim.strength)
			return false;
		if(this.type === Condition.LARGER_THAN && attacker.size < victim.size)
			return false;
		if(this.type === Condition.SMALLER_THAN && attacker.size > victim.size)
			return false;
		

		if(this.type === Condition.RACE && this.data.indexOf(victim.race.id) === -1){return false;}
		if(this.type === Condition.HUMANOID && !victim.race.humanoid){return false;}
		if(this.type === Condition.BEAST && victim.race.humanoid){return false;}
		

		// Check only victim
		if(this.type === Condition.TAGS && !victim.hasAnyTag(this.data))return false;
		if(this.type === Condition.NOT_TAGS && victim.hasAnyTag(this.data)){return false;}


		// Text conditions only
		if(this.type === Condition.ABILITY && (!ability || this.data.indexOf(ability.id) === -1)){ return false; }
		if(this.type === Condition.MISS && success){ return false; }
		
		if(this.type === Condition.SIZE_LESS_THAN_N && victim.size >= this.data[0])
			return false;

		if(this.type === Condition.MANA_GREATER_THAN){
			if(typeof this.data[0] !== 'object'){
				console.error("condition MANA_GREATER_THAN expects an object");
				return false;
			}
			for(i in this.data[0]){
				if(!victim.mana.hasOwnProperty(i)){
					console.error("No such mana type:", i);
					return false;
				}
				if(victim.mana[i] < this.data[0][i]){
					return false;
				}
			}

		}

		return true;

	}

}

// For naked, use Condition.TAGS ["nude"]
Condition.SELF = "SELF";            		// void - Victim is attacker
Condition.FRIEND = "FRIEND";        		// void - Victim is same team as attacker
Condition.ENEMY = "ENEMY";          		// void - Victim is not same team as attacker
Condition.TAGS = "TAGS";            		// (str)tag1, (str)tag2... -  Has ANY of these tags
Condition.ABILITY = "ABILITY";				// [abilityid, abilityid...] - text condition only 
Condition.MISS = "MISS";					// void - text condition only - validates if an ability failed 
Condition.NOT_TAGS = "NOT_TAGS";			// tag1, tag2... - Has NONE of these tags
Condition.RACE = "RACE";					// id1, id2... - Race is ANY of these. Uses id
Condition.HUMANOID = "HUMANOID";			// void - Target is a humanoid
Condition.BEAST = "BEAST";					// void - Target is a beast
Condition.STRONGER_THAN = "STRONGER";		// void - Attacker is stronger than target
Condition.WEAKER_THAN = "WEAKER";			// void - Attacker is weaker than target
Condition.LARGER_THAN = "LARGER";			// void - Attacker is larger than target
Condition.SMALLER_THAN = "SMALLER";			// void - Attacker is smaller than target
Condition.MANA_GREATER_THAN = "MGT";		// [{offensive|defensive|support:(int)val}] - Mana is greater than this value
Condition.SIZE_LESS_THAN_N = "SLTN";		// (int)amount - Target size is smaller than N




// Texts
// This class expects arguments when instantiated
class Text extends Asset{

	constructor(data){
		super();
		this.ait = [];			// AI-tags
		this.conditions = [];
		this.text = "";
		this.sound = "";
		this.debug = false;		// Enables debugging
		this.load(data);
		return this;
	}

	// Validate the conditions
	validate(attacker, victim, ability, success, verbose){
		
		// Check if miss exists, if not, and this is a fail, then return false
		var hasMiss = false;

		for(var i=0; i<this.conditions.length; ++i){
			if(this.conditions[i] === undefined || this.conditions[i].constructor !== Condition)
				console.error("Undefined or invalid type condition in ", this);
			if(this.conditions[i].type === Condition.MISS){hasMiss = true;}
			if(!this.conditions[i].validate(attacker, victim, ability, success, verbose)){
				return false;
			}
		}

		if(!hasMiss && !success){
			return false;
		}

		// Attacker global conditions
		if(!attacker.validateAttackerConditions(victim, ability, success)){
			return false;
		}
		if(!victim.validateVictimConditions(attacker, ability, success)){
			return false;
		}
		

		return true;
	}

	// Converts tags
	convert(attacker, victim, ability){

		var spl = this.text.split(/(:.*?:)/gi);
		var out = [];
		for(var i=0; i<spl.length; ++i){
			if(i%2 != 1){
				out.push(spl[i]);
				continue;
			}
			var short = spl[i].toLowerCase();

			// Special case non-player tags
			if(short === ':abil:'){
				short = ability.name;
			}
			else if(short.charAt(1) === "a"){

				if(!attacker){
					console.error("Trying to convert :A*: label with no attacker defined. Text was ", short);
				}
				// Target attacker
				short = attacker.getLabel(short);
			}
			else{
				// Target attacker
				short = victim.getLabel(short);
			}
			

			out.push(short);
		}

		return out.join('');

	}

	// Fetches a text
	static generate(attacker, victim, ability, success){
		

		var all = DB.Text;
		var allowed = [];

		var verb = false; //ability && ability.id === 'LOW_BLOW';

		for(var i =0; i<all.length; ++i){

			
			if(all[i].validate(attacker, victim, ability, success, verb || all[i].debug)){
				allowed.push(all[i]);
			}

		}
		if(!allowed.length){
			if(success){

				if(attacker === victim)
					allowed = [new Text({text:":ANAME: used :ABIL:."})];
				else
					allowed = [new Text({text:":ANAME: used :ABIL: on :TNAME:."})];
				
			}
			else
				allowed = [new Text({text:":ANAME: tried to use :ABIL: on :TNAME:, but failed!", sound:'fail'})];
			
		}
		
		if(verb){
			console.log("Allowed texts", allowed);
		}
		var text = allowed[Math.floor(Math.random()*allowed.length)];

		
		return text;
	}

	onAdd(){
		var pos = this.ait.indexOf(undefined);
		if(~pos){
			console.error("Undefined AIT in text", this.text, "entry", this.ait);
		}
	}

}

// Widely supported AI tags, modders can write their own obviously
Text.AIT = {
	
	// zone of attack
	aBreasts : 'aBreasts',
	aButt : 'aButt',
	aBody : 'aBody',
	aGroin : 'aGroin',
	aPenis : 'aPenis',
	aVag : 'aVag',
	aMouth : 'aMouth',
	aForeskin : 'aForeskin',
	aTentacle : 'aTentacle',		// A tentacle was involved

	aCloth : 'aCloth',			// Can be combined with above, when attacking clothing specific



	// type of attack
	tSlap : 'tSlap',
	tPunch : 'tPunch',
	tKick : 'tKick',
	tTwist : 'tTwist',
	tTickle : 'tTickle',
	tLick : 'tLick',
	tTug : 'tTug',
	tRub : 'tRub',
	tPin : 'tPin',			// Attacker's penis thrust into zone
	tTwang : 'tTwang',		// Singshotted clothing
	tBite : 'tBite',
	tPinch : 'tPinch',
	tSqueeze : 'tSqueeze',
	tScratch :'tScratch',			// Scratching,. not clawing
	tFacial : 'tFacial',					// Cumming on face
	tCumInside : 'tCumInside',				// Cumming inside
	tCold : 'tCold',						// Cold effects
	tWet : 'tWet',							// A wet attack
	tPen : 'tPen',							// Penetrative, but not with a penis
	tExpose : 'tExpose',					// Expose a player through their clothes
	tFist : 'tFist',						// Fisting


};

/**
 * Text replacers:
 * replace x with A or V/T for attacker or victim/target
 * :xNAME: - Name
 * :xRACE: - Species
 * :xBREASTS: - Breasts, based on breast setting. If no breasts, returns a synonym for breasts.
 * :BUTT: - Synonym for butt
 * :xPENIS: - Penis, based on settings. If not present, returns the same as :CROTCH:
 * :xVAG: - Vagina, based on settings. If not present, returns the same as :CROTCH:
 * :xCROTCHEX: - Vagina, penis, or crotch based on the setting
 * :CROTCH: - Crotch, groin, etc
 * :xBTAG: - Random body part based on the character's bodytags
 * :xHE: - he/she / Custom pronoun
 * :xHIM: - him/her / Custom pronoun
 * :xHIS: - his/her / Custom pronoun
 * :ABIL: - Ability name
 * :xCLOTHES: - Clothing name or "clothes" if not set

 */



class Race extends Asset{

	constructor(data){
		super();
		
		this.id = '';
		this.name_male = "";
		this.name_female = "";		// if not set, name_male will be used instead
		this.description = "";
		this.tags = [];
		this.humanoid = true;
		this.playable = true;
		this.default_icon = '';

		this.load(data);
		return this;
	}

	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			name_male : this.name_male,
			name_female : this.name_female,
			description : this.description,
			tags : this.tags,
			humanoid : this.humanoid,
			playable : this.playable,
			default_icon : this.default_icon
		};
	}

	getName(isFemale){

		if(isFemale && this.name_female){
			return this.name_female;
		}

		return this.name_male;

	}

	onLoaded(){

	}

	// This has been inserted into the database
	onAdd(){
		DB.sort("Race", "name_male");
	}

}



class Challenge extends Asset{

    constructor(data){
        super();
        this.id = '';
		this.name = '';
		this.description = '';
        this.wings = [];
        this.rewards = [];
		this.conditions = [];

        this.load(data);
        return this;
    }

}

class ChallengeWing extends Asset{
	
	constructor(data){
        super();
        this.id = '';
		this.name = '';
		this.description = '';
        this.stages = [];
        this.rewards = [];

        this.load(data);
        return this;
    }

}

class ChallengeStage extends Asset{

    constructor(data){

        super();
        this.id = '';
        this.icon = '';
		this.name = '';
		this.description = '';
        this.npcs = [];


        this.load(data);
        return this;
    }

}

class ChallengeReward extends Asset{

	constructor(data){

        super();
        this.id = '';
        this.type = '';

        this.load(data);
        return this;
    }

}

